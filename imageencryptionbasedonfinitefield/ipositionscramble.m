function outImgI1=ipositionscramble(P)
%%类似于猫映射变换的置换多项式的置乱   256*256图像
%置乱(逆变换);
xx = gf(0:255,8); % 生成1*256一维有限域
m0=zeros(1,256);
for i=0:255
    m0(i+1)=i;
end  
w0=xx(3).^double(m0);
w0(256)=0;

e=xx(3)^127;      %密钥分析
%行置换密钥
e1=xx(3)^11;
% 原始密钥
p1=191;   
q1=193;
% p11=181;
% p11=1048507;
% p11=981683; 
% p11=557741;   不同范围的密钥，多取几组。
% q2 = 127;
% p2= 181;
%行置换多项式
%p1+255 为负数时采取下面的方法，因为0的负任何次方没有值。
wi1=(((w0+e1).^59+(w0+e1).^209+(w0+e1).^254).^(q1));
for i=1:256
    if(wi1(i)==0)
        wi1(i)=1;
        k=i;
    end   
end   
w1=(wi1).^(-p1+255);
w1(k)=0;

% %p1+255 为正数时采取下面的方法
% w1=(((w0+e1).^59+(w0+e1).^209+(w0+e1).^254).^(q1)).^(-p1+255);

%列置换密钥

e2=xx(3)^19;   
% % w2=((w0+e2).^59+(w0+e2).^209+(w0+e2).^254).^(q1/p1);
w2=(((w0+e2).^59+(w0+e2).^209+(w0+e2).^254).^(q1)).^(-p1+255);
% w22=w2.x;
%%类似于猫映射变换的置换多项式的置乱
%置乱(逆变换);
w11=w1.x;
w22=w2.x;
iw1=zeros(1,256);
for j=1:256
     iw1(w11(j)+1)=j;
end  

iw2=zeros(1,256);
for i=1:256
    iw2(w22(i)+1)=i;
end

tempImg1=P;
outImgI1 = P;
% tempImg1=outImg;
% outImgI1 = outImg;
[m,n]=size(P);
for u=1:m
    for v=1:n
             temp = tempImg1(u,v);     %获取坐标（U,V）的像素值
             ax=iw1(u);
             ay=iw2(v);
            outImgI1(ax,ay) = temp;          %在新的坐标中附上原来的像素值
    end   
end 

% y=gf(0:511,9);
% m0=zeros(1,512);
% for i=0:511
%     m0(i+1)=i;
% end  
% w0=y(3).^double(m0);
%  w0(512)=0;
% % w1=((w0+e1)+(w0+e1).^3+(w0+e1).^33).^(p/q);
% w1=((w0)+(w0).^3+(w0).^33);
% w2=((w0)+(w0).^171+(w0).^341);